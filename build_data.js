import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const charactersDir = path.join(__dirname, 'src', 'data', 'source', 'data');
const eventsDir = path.join(__dirname, 'src', 'data', 'source', 'events');
const outputJsPath = path.join(__dirname, 'public', 'resources', 'characters-data.js');
const outputJsonPath = path.join(__dirname, 'public', 'resources', 'characters.json');

function stripComments(jsonString) {
    // Regex to match strings or comments
    const regex = /\\"|"(?:\\"|[^"])*"|(\/\/.*|\/\*[\s\S]*?\*\/)/g;
    return jsonString.replace(regex, (match, comment) => {
        if (comment) {
            return ''; // Remove comment
        }
        return match; // Keep string
    });
}

function readJsonFiles(dir) {
    if (!fs.existsSync(dir)) return [];
    const files = fs.readdirSync(dir).filter(file => file.endsWith('.json'));
    const results = [];
    files.forEach(file => {
        const filePath = path.join(dir, file);
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            const data = JSON.parse(stripComments(content));
            results.push(data);
        } catch (err) {
            console.error(`Error reading ${file}:`, err.message);
        }
    });
    return results;
}

function updateData() {
    console.log('Updating game data...');
    
    // 1. Load Characters
    const charactersList = readJsonFiles(charactersDir);
    const charactersData = {};
    charactersList.forEach(char => {
        if (char.id) {
            charactersData[char.id] = char;
        }
    });

    // 2. Load Events
    // Events can be individual objects or arrays of objects
    const eventsListRaw = readJsonFiles(eventsDir);
    let eventsData = [];
    eventsListRaw.forEach(item => {
        if (Array.isArray(item)) {
            eventsData = eventsData.concat(item);
        } else {
            eventsData.push(item);
        }
    });

    // 3. Write Output
    const combinedData = {
        characters: charactersData,
        events: eventsData
    };

    // Write JSON file (optional, mostly for debug or other tools)
    fs.writeFileSync(outputJsonPath, JSON.stringify(combinedData, null, 4), 'utf8');
    console.log(`Generated ${outputJsonPath}`);

    // Write JS file for frontend
    // We export two global variables: window.charactersData and window.eventsData
    // Replace .png/.jpg with .webp in the output
    const jsonStr = JSON.stringify(charactersData, null, 4).replace(/\.png/g, '.webp').replace(/\.jpg/g, '.webp');
    const eventsStr = JSON.stringify(eventsData, null, 4).replace(/\.png/g, '.webp').replace(/\.jpg/g, '.webp');

    const jsContent = `// Auto-generated by build_data.js
window.charactersData = ${jsonStr};
window.eventsData = ${eventsStr};
`;
    fs.writeFileSync(outputJsPath, jsContent, 'utf8');
    console.log(`Generated ${outputJsPath}`);
}

// Initial update
updateData();

// Watch mode
if (process.argv.includes('--watch')) {
    console.log(`Watching for changes...`);
    
    const watchHandler = (eventType, filename) => {
        if (filename && filename.endsWith('.json')) {
            console.log(`Detected change in ${filename} (${eventType})`);
            updateData();
        }
    };

    if (fs.existsSync(charactersDir)) fs.watch(charactersDir, watchHandler);
    if (fs.existsSync(eventsDir)) fs.watch(eventsDir, watchHandler);
}
